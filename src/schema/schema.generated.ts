/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * Representations of scalar types
 */
export type TypeRepresentation =
  | {
      type: "boolean";
    }
  | {
      type: "string";
    }
  | {
      type: "int8";
    }
  | {
      type: "int16";
    }
  | {
      type: "int32";
    }
  | {
      type: "int64";
    }
  | {
      type: "float32";
    }
  | {
      type: "float64";
    }
  | {
      type: "biginteger";
    }
  | {
      type: "bigdecimal";
    }
  | {
      type: "uuid";
    }
  | {
      type: "date";
    }
  | {
      type: "timestamp";
    }
  | {
      type: "timestamptz";
    }
  | {
      type: "geography";
    }
  | {
      type: "geometry";
    }
  | {
      type: "bytes";
    }
  | {
      type: "json";
    }
  | {
      type: "enum";
      one_of: string[];
    };
/**
 * The definition of an aggregation function on a scalar type
 */
export type AggregateFunctionDefinition =
  | {
      type: "min";
    }
  | {
      type: "max";
    }
  | {
      type: "sum";
      /**
       * The scalar type of the result of this function, which should have one of the type representations Int64 or Float64, depending on whether this function is defined on a scalar type with an integer or floating-point representation, respectively.
       */
      result_type: string;
    }
  | {
      type: "average";
      /**
       * The scalar type of the result of this function, which should have the type representation Float64
       */
      result_type: string;
    }
  | {
      type: "custom";
      /**
       * The scalar or object type of the result of this function
       */
      result_type: Type;
    };
/**
 * Types track the valid representations of values as JSON
 */
export type Type =
  | {
      type: "named";
      /**
       * The name can refer to a scalar or object type
       */
      name: string;
    }
  | {
      type: "nullable";
      /**
       * The type of the non-null inhabitants of this type
       */
      underlying_type: Type;
    }
  | {
      type: "array";
      /**
       * The type of the elements of the array
       */
      element_type: Type;
    }
  | {
      type: "predicate";
      /**
       * The object type name
       */
      object_type_name: string;
    };
/**
 * The definition of a comparison operator on a scalar type
 */
export type ComparisonOperatorDefinition =
  | {
      type: "equal";
    }
  | {
      type: "in";
    }
  | {
      type: "less_than";
    }
  | {
      type: "less_than_or_equal";
    }
  | {
      type: "greater_than";
    }
  | {
      type: "greater_than_or_equal";
    }
  | {
      type: "custom";
      /**
       * The type of the argument to this operator
       */
      argument_type: Type;
    };
export type Aggregate =
  | {
      type: "column_count";
      /**
       * The column to apply the count aggregate function to
       */
      column: string;
      /**
       * Arguments to satisfy the column specified by 'column'
       */
      arguments?: {
        [k: string]: Argument;
      };
      /**
       * Path to a nested field within an object column
       */
      field_path?: string[] | null;
      /**
       * Whether or not only distinct items should be counted
       */
      distinct: boolean;
    }
  | {
      type: "single_column";
      /**
       * The column to apply the aggregation function to
       */
      column: string;
      /**
       * Arguments to satisfy the column specified by 'column'
       */
      arguments?: {
        [k: string]: Argument;
      };
      /**
       * Path to a nested field within an object column
       */
      field_path?: string[] | null;
      /**
       * Single column aggregate function name.
       */
      function: string;
    }
  | {
      type: "star_count";
    };
export type Argument =
  | {
      type: "variable";
      name: string;
    }
  | {
      type: "literal";
      value: unknown;
    };
export type Field =
  | {
      type: "column";
      column: string;
      /**
       * When the type of the column is a (possibly-nullable) array or object, the caller can request a subset of the complete column data, by specifying fields to fetch here. If omitted, the column data will be fetched in full.
       */
      fields?: NestedField | null;
      arguments?: {
        [k: string]: Argument;
      };
    }
  | {
      type: "relationship";
      query: Query;
      /**
       * The name of the relationship to follow for the subquery
       */
      relationship: string;
      /**
       * Values to be provided to any collection arguments
       */
      arguments: {
        [k: string]: RelationshipArgument;
      };
    };
export type NestedField = NestedObject | NestedArray | NestedCollection;
export type RelationshipArgument =
  | {
      type: "variable";
      name: string;
    }
  | {
      type: "literal";
      value: unknown;
    }
  | {
      type: "column";
      name: string;
    };
export type OrderDirection = "asc" | "desc";
export type OrderByTarget =
  | {
      type: "column";
      /**
       * Any (object) relationships to traverse to reach this column. Only non-empty if the 'relationships' capability is supported.
       */
      path: PathElement[];
      /**
       * The name of the column
       */
      name: string;
      /**
       * Arguments to satisfy the column specified by 'name'
       */
      arguments?: {
        [k: string]: Argument;
      };
      /**
       * Path to a nested field within an object column. Only non-empty if the 'query.nested_fields.order_by' capability is supported.
       */
      field_path?: string[] | null;
    }
  | {
      type: "aggregate";
      /**
       * Non-empty collection of relationships to traverse
       */
      path: PathElement[];
      /**
       * The aggregation method to use
       */
      aggregate: Aggregate;
    };
export type Expression =
  | {
      type: "and";
      expressions: Expression[];
    }
  | {
      type: "or";
      expressions: Expression[];
    }
  | {
      type: "not";
      expression: Expression;
    }
  | {
      type: "unary_comparison_operator";
      column: ComparisonTarget;
      operator: UnaryComparisonOperator;
    }
  | {
      type: "binary_comparison_operator";
      column: ComparisonTarget;
      operator: string;
      value: ComparisonValue;
    }
  | {
      type: "array_comparison";
      column: ComparisonTarget;
      comparison: ArrayComparison;
    }
  | {
      type: "exists";
      in_collection: ExistsInCollection;
      predicate?: Expression | null;
    };
export type ComparisonTarget =
  | {
      type: "column";
      /**
       * The name of the column
       */
      name: string;
      /**
       * Arguments to satisfy the column specified by 'name'
       */
      arguments?: {
        [k: string]: Argument;
      };
      /**
       * Path to a nested field within an object column. Only non-empty if the 'query.nested_fields.filter_by' capability is supported.
       */
      field_path?: string[] | null;
    }
  | {
      type: "aggregate";
      /**
       * Non-empty collection of relationships to traverse
       */
      path: PathElement[];
      /**
       * The aggregation method to use
       */
      aggregate: Aggregate;
    };
export type UnaryComparisonOperator = "is_null";
export type ComparisonValue =
  | {
      type: "column";
      /**
       * Any relationships to traverse to reach this column. Only non-empty if the 'relationships.relation_comparisons' is supported.
       */
      path: PathElement[];
      /**
       * The name of the column
       */
      name: string;
      /**
       * Arguments to satisfy the column specified by 'name'
       */
      arguments?: {
        [k: string]: Argument;
      };
      /**
       * Path to a nested field within an object column. Only non-empty if the 'query.nested_fields.filter_by' capability is supported.
       */
      field_path?: string[] | null;
      /**
       * The scope in which this column exists, identified by an top-down index into the stack of scopes. The stack grows inside each `Expression::Exists`, so scope 0 (the default) refers to the current collection, and each subsequent index refers to the collection outside its predecessor's immediately enclosing `Expression::Exists` expression. Only used if the 'query.exists.named_scopes' capability is supported.
       */
      scope?: number | null;
    }
  | {
      type: "scalar";
      value: unknown;
    }
  | {
      type: "variable";
      name: string;
    };
export type ArrayComparison =
  | {
      type: "contains";
      value: ComparisonValue;
    }
  | {
      type: "is_empty";
    };
export type ExistsInCollection =
  | {
      type: "related";
      /**
       * Path to a nested field within an object column that must be navigated before the relationship is navigated Only non-empty if the 'relationships.nested' capability is supported.
       */
      field_path?: string[] | null;
      /**
       * The name of the relationship to follow
       */
      relationship: string;
      /**
       * Values to be provided to any collection arguments
       */
      arguments: {
        [k: string]: RelationshipArgument;
      };
    }
  | {
      type: "unrelated";
      /**
       * The name of a collection
       */
      collection: string;
      /**
       * Values to be provided to any collection arguments
       */
      arguments: {
        [k: string]: RelationshipArgument;
      };
    }
  | {
      type: "nested_collection";
      column_name: string;
      arguments?: {
        [k: string]: Argument;
      };
      /**
       * Path to a nested collection via object columns
       */
      field_path?: string[];
    }
  | {
      type: "nested_scalar_collection";
      column_name: string;
      arguments?: {
        [k: string]: Argument;
      };
      /**
       * Path to a nested collection via object columns
       */
      field_path?: string[];
    };
export type Dimension = {
  type: "column";
  /**
   * Any (object) relationships to traverse to reach this column. Only non-empty if the 'relationships' capability is supported.
   */
  path: PathElement[];
  /**
   * The name of the column
   */
  column_name: string;
  /**
   * Arguments to satisfy the column specified by 'column_name'
   */
  arguments?: {
    [k: string]: Argument;
  };
  /**
   * Path to a nested field within an object column
   */
  field_path?: string[] | null;
};
export type GroupExpression =
  | {
      type: "and";
      expressions: GroupExpression[];
    }
  | {
      type: "or";
      expressions: GroupExpression[];
    }
  | {
      type: "not";
      expression: GroupExpression;
    }
  | {
      type: "unary_comparison_operator";
      target: AggregateComparisonTarget;
      operator: UnaryComparisonOperator;
    }
  | {
      type: "binary_comparison_operator";
      target: AggregateComparisonTarget;
      operator: string;
      value: AggregateComparisonValue;
    };
export type AggregateComparisonTarget = {
  type: "aggregate";
  aggregate: Aggregate;
};
export type AggregateComparisonValue =
  | {
      type: "scalar";
      value: unknown;
    }
  | {
      type: "variable";
      name: string;
    };
export type GroupOrderByTarget =
  | {
      type: "dimension";
      /**
       * The index of the dimension to order by, selected from the dimensions provided in the `Grouping` request.
       */
      index: number;
    }
  | {
      type: "aggregate";
      /**
       * Aggregation method to apply
       */
      aggregate: Aggregate;
    };
export type RelationshipType = "object" | "array";
/**
 * Query responses may return multiple RowSets when using queries with variables. Else, there should always be exactly one RowSet
 */
export type QueryResponse = RowSet[];
export type MutationOperation = {
  type: "procedure";
  /**
   * The name of a procedure
   */
  name: string;
  /**
   * Any named procedure arguments
   */
  arguments: {
    [k: string]: unknown;
  };
  /**
   * The fields to return from the result, or null to return everything
   */
  fields?: NestedField | null;
};
export type MutationOperationResults = {
  type: "procedure";
  result: unknown;
};

export interface SchemaRoot {
  capabilities_response: CapabilitiesResponse;
  schema_response: SchemaResponse;
  query_request: QueryRequest;
  query_response: QueryResponse;
  mutation_request: MutationRequest;
  mutation_response: MutationResponse;
  explain_response: ExplainResponse;
  error_response: ErrorResponse;
  validate_response: ValidateResponse;
}
export interface CapabilitiesResponse {
  version: string;
  capabilities: Capabilities;
}
/**
 * Describes the features of the specification which a data connector implements.
 */
export interface Capabilities {
  query: QueryCapabilities;
  mutation: MutationCapabilities;
  relationships?: RelationshipCapabilities | null;
}
export interface QueryCapabilities {
  /**
   * Does the connector support aggregate queries
   */
  aggregates?: AggregateCapabilities | null;
  /**
   * Does the connector support queries which use variables
   */
  variables?: LeafCapability | null;
  /**
   * Does the connector support explaining queries
   */
  explain?: LeafCapability | null;
  /**
   * Does the connector support nested fields
   */
  nested_fields?: NestedFieldCapabilities;
  /**
   * Does the connector support EXISTS predicates
   */
  exists?: ExistsCapabilities;
}
export interface AggregateCapabilities {
  /**
   * Does the connector support filtering based on aggregated values
   */
  filter_by?: LeafCapability | null;
  /**
   * Does the connector support aggregations over groups
   */
  group_by?: GroupByCapabilities | null;
}
/**
 * A unit value to indicate a particular leaf capability is supported. This is an empty struct to allow for future sub-capabilities.
 */
export interface LeafCapability {}
export interface GroupByCapabilities {
  /**
   * Does the connector support post-grouping predicates
   */
  filter?: LeafCapability | null;
  /**
   * Does the connector support post-grouping ordering
   */
  order?: LeafCapability | null;
  /**
   * Does the connector support post-grouping pagination
   */
  paginate?: LeafCapability | null;
}
export interface NestedFieldCapabilities {
  /**
   * Does the connector support filtering by values of nested fields
   */
  filter_by?: NestedFieldFilterByCapabilities | null;
  /**
   * Does the connector support ordering by values of nested fields
   */
  order_by?: LeafCapability | null;
  /**
   * Does the connector support aggregating values within nested fields
   */
  aggregates?: LeafCapability | null;
  /**
   * Does the connector support nested collection queries using `NestedField::NestedCollection`
   */
  nested_collections?: LeafCapability | null;
}
export interface NestedFieldFilterByCapabilities {
  /**
   * Does the connector support filtering over nested arrays (ie. Expression::ArrayComparison)
   */
  nested_arrays?: NestedArrayFilterByCapabilities | null;
}
export interface NestedArrayFilterByCapabilities {
  /**
   * Does the connector support filtering over nested arrays by checking if the array contains a value. This must be supported for all types that can be contained in an array that implement an 'eq' comparison operator.
   */
  contains?: LeafCapability | null;
  /**
   * Does the connector support filtering over nested arrays by checking if the array is empty. This must be supported no matter what type is contained in the array.
   */
  is_empty?: LeafCapability | null;
}
export interface ExistsCapabilities {
  /**
   * Does the connector support named scopes in column references inside EXISTS predicates
   */
  named_scopes?: LeafCapability | null;
  /**
   * Does the connector support ExistsInCollection::Unrelated
   */
  unrelated?: LeafCapability | null;
  /**
   * Does the connector support ExistsInCollection::NestedCollection
   */
  nested_collections?: LeafCapability | null;
  /**
   * Does the connector support filtering over nested scalar arrays using existential quantification. This means the connector must support ExistsInCollection::NestedScalarCollection.
   */
  nested_scalar_collections?: LeafCapability | null;
}
export interface MutationCapabilities {
  /**
   * Does the connector support executing multiple mutations in a transaction.
   */
  transactional?: LeafCapability | null;
  /**
   * Does the connector support explaining mutations
   */
  explain?: LeafCapability | null;
}
export interface RelationshipCapabilities {
  /**
   * Does the connector support comparisons that involve related collections (ie. joins)?
   */
  relation_comparisons?: LeafCapability | null;
  /**
   * Does the connector support ordering by an aggregated array relationship?
   */
  order_by_aggregate?: LeafCapability | null;
  /**
   * Does the connector support navigating a relationship from inside a nested object
   */
  nested?: NestedRelationshipCapabilities | null;
}
export interface NestedRelationshipCapabilities {
  /**
   * Does the connector support navigating a relationship from inside a nested object inside a nested array
   */
  array?: LeafCapability | null;
}
export interface SchemaResponse {
  /**
   * A list of scalar types which will be used as the types of collection columns
   */
  scalar_types: {
    [k: string]: ScalarType;
  };
  /**
   * A list of object types which can be used as the types of arguments, or return types of procedures. Names should not overlap with scalar type names.
   */
  object_types: {
    [k: string]: ObjectType;
  };
  /**
   * Collections which are available for queries
   */
  collections: CollectionInfo[];
  /**
   * Functions (i.e. collections which return a single column and row)
   */
  functions: FunctionInfo[];
  /**
   * Procedures which are available for execution as part of mutations
   */
  procedures: ProcedureInfo[];
  /**
   * Schema data which is relevant to features enabled by capabilities
   */
  capabilities?: CapabilitySchemaInfo | null;
}
/**
 * The definition of a scalar type, i.e. types that can be used as the types of columns.
 */
export interface ScalarType {
  /**
   * A description of valid values for this scalar type.
   */
  representation: TypeRepresentation;
  /**
   * A map from aggregate function names to their definitions. Result type names must be defined scalar types declared in ScalarTypesCapabilities.
   */
  aggregate_functions: {
    [k: string]: AggregateFunctionDefinition;
  };
  /**
   * A map from comparison operator names to their definitions. Argument type names must be defined scalar types declared in ScalarTypesCapabilities.
   */
  comparison_operators: {
    [k: string]: ComparisonOperatorDefinition;
  };
}
/**
 * The definition of an object type
 */
export interface ObjectType {
  /**
   * Description of this type
   */
  description?: string | null;
  /**
   * Fields defined on this object type
   */
  fields: {
    [k: string]: ObjectField;
  };
  /**
   * Any foreign keys defined for this object type's columns
   */
  foreign_keys: {
    [k: string]: ForeignKeyConstraint;
  };
}
/**
 * The definition of an object field
 */
export interface ObjectField {
  /**
   * Description of this field
   */
  description?: string | null;
  /**
   * The type of this field
   */
  type: Type;
  /**
   * The arguments available to the field - Matches implementation from CollectionInfo
   */
  arguments?: {
    [k: string]: ArgumentInfo;
  };
}
export interface ArgumentInfo {
  /**
   * Argument description
   */
  description?: string | null;
  /**
   * The name of the type of this argument
   */
  type: Type;
}
export interface ForeignKeyConstraint {
  /**
   * The columns on which you want want to define the foreign key. This is a mapping between fields on object type to columns on the foreign collection. The column on the foreign collection is specified via a field path (ie. an array of field names that descend through nested object fields). The field path must only contain a single item, meaning a column on the foreign collection's type, unless the 'relationships.nested' capability is supported, in which case multiple items can be used to denote a nested object field.
   */
  column_mapping: {
    [k: string]: string[];
  };
  /**
   * The name of a collection
   */
  foreign_collection: string;
}
export interface CollectionInfo {
  /**
   * The name of the collection
   *
   * Note: these names are abstract - there is no requirement that this name correspond to the name of an actual collection in the database.
   */
  name: string;
  /**
   * Description of the collection
   */
  description?: string | null;
  /**
   * Any arguments that this collection requires
   */
  arguments: {
    [k: string]: ArgumentInfo;
  };
  /**
   * The name of the collection's object type
   */
  type: string;
  /**
   * Any uniqueness constraints enforced on this collection
   */
  uniqueness_constraints: {
    [k: string]: UniquenessConstraint;
  };
}
export interface UniquenessConstraint {
  /**
   * A list of columns which this constraint requires to be unique
   */
  unique_columns: string[];
}
export interface FunctionInfo {
  /**
   * The name of the function
   */
  name: string;
  /**
   * Description of the function
   */
  description?: string | null;
  /**
   * Any arguments that this collection requires
   */
  arguments: {
    [k: string]: ArgumentInfo;
  };
  /**
   * The name of the function's result type
   */
  result_type: Type;
}
export interface ProcedureInfo {
  /**
   * The name of the procedure
   */
  name: string;
  /**
   * Column description
   */
  description?: string | null;
  /**
   * Any arguments that this collection requires
   */
  arguments: {
    [k: string]: ArgumentInfo;
  };
  /**
   * The name of the result type
   */
  result_type: Type;
}
export interface CapabilitySchemaInfo {
  /**
   * Schema information relevant to query capabilities
   */
  query?: QueryCapabilitiesSchemaInfo | null;
}
export interface QueryCapabilitiesSchemaInfo {
  /**
   * Schema information relevant to aggregate query capabilities
   */
  aggregates?: AggregateCapabilitiesSchemaInfo | null;
}
export interface AggregateCapabilitiesSchemaInfo {
  /**
   * Schema information relevant to the aggregates.filter_by capability
   */
  filter_by?: AggregateFilterByCapabilitiesSchemaInfo | null;
}
export interface AggregateFilterByCapabilitiesSchemaInfo {
  /**
   * The scalar type which should be used for the return type of count (star_count and column_count) operations.
   */
  count_scalar_type: string;
}
/**
 * This is the request body of the query POST endpoint
 */
export interface QueryRequest {
  /**
   * The name of a collection
   */
  collection: string;
  /**
   * The query syntax tree
   */
  query: Query;
  /**
   * Values to be provided to any collection arguments
   */
  arguments: {
    [k: string]: Argument;
  };
  /**
   * Any relationships between collections involved in the query request. Only used if the 'relationships' capability is supported.
   */
  collection_relationships: {
    [k: string]: Relationship;
  };
  /**
   * One set of named variables for each rowset to fetch. Each variable set should be subtituted in turn, and a fresh set of rows returned. Only used if the 'query.variables' capability is supported.
   */
  variables?:
    | {
        [k: string]: unknown;
      }[]
    | null;
}
export interface Query {
  /**
   * Aggregate fields of the query. Only used if the 'query.aggregates' capability is supported.
   */
  aggregates?: {
    [k: string]: Aggregate;
  } | null;
  /**
   * Fields of the query
   */
  fields?: {
    [k: string]: Field;
  } | null;
  /**
   * Optionally limit to N results
   */
  limit?: number | null;
  /**
   * Optionally offset from the Nth result
   */
  offset?: number | null;
  /**
   * Optionally specify how rows should be ordered
   */
  order_by?: OrderBy | null;
  /**
   * Optionally specify a predicate to apply to the rows
   */
  predicate?: Expression | null;
  /**
   * Optionally group and aggregate the selected rows. Only used if the 'query.aggregates.group_by' capability is supported.
   */
  groups?: Grouping | null;
}
export interface NestedObject {
  type: "object";
  fields: {
    [k: string]: Field;
  };
}
export interface NestedArray {
  type: "array";
  fields: NestedField;
}
/**
 * Perform a query over the nested array's rows. Only used if the 'query.nested_fields.nested_collections' capability is supported.
 */
export interface NestedCollection {
  type: "collection";
  query: Query;
}
export interface OrderBy {
  /**
   * The elements to order by, in priority order
   */
  elements: OrderByElement[];
}
export interface OrderByElement {
  order_direction: OrderDirection;
  target: OrderByTarget;
}
export interface PathElement {
  /**
   * Path to a nested field within an object column that must be navigated before the relationship is navigated. Only non-empty if the 'relationships.nested' capability is supported.
   */
  field_path?: string[] | null;
  /**
   * The name of the relationship to follow
   */
  relationship: string;
  /**
   * Values to be provided to any collection arguments
   */
  arguments: {
    [k: string]: RelationshipArgument;
  };
  /**
   * A predicate expression to apply to the target collection
   */
  predicate?: Expression | null;
}
export interface Grouping {
  /**
   * Dimensions along which to partition the data
   */
  dimensions: Dimension[];
  /**
   * Aggregates to compute in each group
   */
  aggregates: {
    [k: string]: Aggregate;
  };
  /**
   * Optionally specify a predicate to apply after grouping rows. Only used if the 'query.aggregates.group_by.filter' capability is supported.
   */
  predicate?: GroupExpression | null;
  /**
   * Optionally specify how groups should be ordered Only used if the 'query.aggregates.group_by.order' capability is supported.
   */
  order_by?: GroupOrderBy | null;
  /**
   * Optionally limit to N groups Only used if the 'query.aggregates.group_by.paginate' capability is supported.
   */
  limit?: number | null;
  /**
   * Optionally offset from the Nth group Only used if the 'query.aggregates.group_by.paginate' capability is supported.
   */
  offset?: number | null;
}
export interface GroupOrderBy {
  /**
   * The elements to order by, in priority order
   */
  elements: GroupOrderByElement[];
}
export interface GroupOrderByElement {
  order_direction: OrderDirection;
  target: GroupOrderByTarget;
}
export interface Relationship {
  /**
   * A mapping between columns on the source row to columns on the target collection. The column on the target collection is specified via a field path (ie. an array of field names that descend through nested object fields). The field path will only contain a single item, meaning a column on the target collection's type, unless the 'relationships.nested' capability is supported, in which case multiple items denotes a nested object field.
   */
  column_mapping: {
    [k: string]: string[];
  };
  relationship_type: RelationshipType;
  /**
   * The name of a collection
   */
  target_collection: string;
  /**
   * Values to be provided to any collection arguments
   */
  arguments: {
    [k: string]: RelationshipArgument;
  };
}
export interface RowSet {
  /**
   * The results of the aggregates returned by the query
   */
  aggregates?: {
    [k: string]: unknown;
  } | null;
  /**
   * The rows returned by the query, corresponding to the query's fields
   */
  rows?:
    | {
        [k: string]: RowFieldValue;
      }[]
    | null;
  /**
   * The results of any grouping operation
   */
  groups?: Group[] | null;
}
export type RowFieldValue = unknown; // Manually corrected :(
export interface Group {
  /**
   * Values of dimensions which identify this group
   */
  dimensions: unknown[];
  /**
   * Aggregates computed within this group
   */
  aggregates: {
    [k: string]: unknown;
  };
}
export interface MutationRequest {
  /**
   * The mutation operations to perform
   */
  operations: MutationOperation[];
  /**
   * The relationships between collections involved in the entire mutation request. Only used if the 'relationships' capability is supported.
   */
  collection_relationships: {
    [k: string]: Relationship;
  };
}
export interface MutationResponse {
  /**
   * The results of each mutation operation, in the same order as they were received
   */
  operation_results: MutationOperationResults[];
}
export interface ExplainResponse {
  /**
   * A list of human-readable key-value pairs describing a query execution plan. For example, a connector for a relational database might return the generated SQL and/or the output of the `EXPLAIN` command. An API-based connector might encode a list of statically-known API calls which would be made.
   */
  details: {
    [k: string]: string;
  };
}
export interface ErrorResponse {
  /**
   * A human-readable summary of the error
   */
  message: string;
  /**
   * Any additional structured information about the error
   */
  details: {
    [k: string]: unknown;
  };
}
export interface ValidateResponse {
  schema: SchemaResponse;
  capabilities: CapabilitiesResponse;
  resolved_configuration: string;
}
